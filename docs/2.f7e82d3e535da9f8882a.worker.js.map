{"version":3,"sources":["webpack://Conways/webpack/bootstrap","webpack://Conways/./src/lib/entity-system/CellStates.js","webpack://Conways/./src/lib/entity-system/Entities.js","webpack://Conways/./src/lib/workers/WorkerCommands.js","webpack://Conways/./src/lib/core/CellEvaluator.js","webpack://Conways/./src/lib/core/SeederFactory.js","webpack://Conways/./src/lib/workers/LifeSystem.worker.js","webpack://Conways/./src/lib/workers/WorkerUtils.js","webpack://Conways/./src/lib/workers/LifeSystemWorkerController.js","webpack://Conways/./src/lib/core/LifeSystem.js","webpack://Conways/./src/lib/core/GameManager.js","webpack://Conways/./src/lib/core/CellMortonStore.js","webpack://Conways/./src/lib/core/SceneManager.js","webpack://Conways/./src/lib/workers/AbstractWorkerController.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACTA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,CAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClPA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;;;;;;;AC7CA,mBAAmB,mBAAO,CAAC,CAAkC;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,qCAAqC;AACrC,GAAG;AACH;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA,sCAAsC;AACtC;AACA,GAAG;AACH;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,cAAc,UAAU;AACxB;AACA;AACA,sCAAsC;AACtC;AACA;AACA,sCAAsC;AACtC;AACA,GAAG;AACH;AACA;AACA;AACA,yBAAyB;AACzB,GAAG;AACH;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;;AAEA,kBAAkB;;;;;;;AC5GlB;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,CAAkC;AAC7D,OAAO,OAAO,GAAG,mBAAO,CAAC,CAAgC;;AAEzD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,WAAW;AAC5B,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;ACnIlB;AACA;AACA;AACA,OAAO,yBAAyB,GAAG,mBAAO,CAAC,CAAkB;AAC7D,mCAAmC,mBAAO,CAAC,CAA8B;;AAEzE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACnBA;AACA;AACA;;AAEA,kBAAkB;;;;;;;ACJlB,uBAAuB,mBAAO,CAAC,CAAqB;AACpD;AACA,mBAAmB,mBAAO,CAAC,CAAyB;;AAEpD;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,EAA+B;AAC3C,OAAO,gBAAgB,GAAG,mBAAO,CAAC,CAA4B;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;;;;;;AClKA,oBAAoB,mBAAO,CAAC,CAAkB;AAC9C,qBAAqB,mBAAO,CAAC,EAAmB;AAChD;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,CAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;;AAEA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxMA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,EAAsB;AAC1D,OAAO,gBAAgB,GAAG,mBAAO,CAAC,CAAoB;AACtD,OAAO,OAAO,GAAG,mBAAO,CAAC,CAA8B;AACvD,mBAAmB,mBAAO,CAAC,CAAkC;AAC7D,OAAO,8BAA8B,GAAG,mBAAO,CAAC,CAAoB;;AAEpE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mCAAmC;AACtD,oBAAoB,oCAAoC;AACxD;AACA,MAAM,qBAAqB;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC1LA;AACA;AACA,aAAa;AACb,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;AACjC,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,cAAc;AACpC,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;AC5GlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kBAAkB;AAC9B,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACzDA,uBAAuB,mBAAO,CAAC,CAAqB;AACpD;AACA,OAAO,OAAO,GAAG,mBAAO,CAAC,CAAgC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA,OAAO,sBAAsB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH,iDAAiD,YAAY,IAAI,OAAO;AACxE;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,UAAU,OAAO;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB","file":"2.f7e82d3e535da9f8882a.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/**\n * Defines the possible states a Cell can have.\n */\nconst CellStates = {\n\tDEAD: 0,\n\tACTIVE: 1,\n\tRETIRED: 2\n};\n\nmodule.exports = CellStates;\n","/**\n * A module for defining render-able entities with traits.\n * @module entity_system\n */\n\nconst CellStates = require('./CellStates.js');\n\n/**\n * A render-able entity. The entity is defined by registering traits.\n */\nclass Entity {\n\t/**\n\t * Create a new Entity.\n\t */\n\tconstructor() {\n\t\tthis.traits = [];\n\t\tthis.className = 'Entity';\n\t}\n\n\t/**\n\t * Process all register traits.\n\t * @param {HTMLCanvasContext} rendererContext\n\t */\n\trender(rendererContext) {\n\t\tlet context = {\n\t\t\trendererContext: rendererContext,\n\t\t\tentity: this,\n\t\t};\n\t\tthis.traits.forEach((trait) => {\n\t\t\ttrait.process(context);\n\t\t});\n\t}\n\n\t/**\n\t * Expands the definition of the entity by registering traits.\n\t * @param {Trait} trait - An implementation of the Trait abstract class.\n\t */\n\tregister(trait) {\n\t\tthis.traits.push(trait);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Automatically called by JSON.stringify().\n\t * Injects the original class name as a property when serialized\n\t * which an be used to rebuild a Scene after communicated from a thread.\n\t * @returns Entity\n\t */\n\ttoJSON() {\n\t\tthis.className = this.constructor.name;\n\t\treturn this;\n\t}\n\n\tcopyParams(original) {\n\t\tfor (var key in original) {\n\t\t\tif (key != 'className' && key != 'traits') {\n\t\t\t\tthis[key] = original[key];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tinitTraits(original, traitBuilderFactory) {\n\t\tthis.traits = original.traits.map((traitLit) => {\n\t\t\tvar traitBuilder = traitBuilderFactory(traitLit.className);\n\t\t\treturn traitBuilder ? traitBuilder(traitLit) : new Trait();\n\t\t});\n\t\treturn this;\n\t}\n}\n\nclass EntityBatch extends Entity {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.entities = [];\n\t}\n\n\tadd(entity) {\n\t\tif (entity && Array.isArray(entity) && entity.length > 0) {\n\t\t\tthis.entities = this.entities.concat(entity);\n\t\t} else {\n\t\t\tentity && this.entities.push(entity);\n\t\t}\n\t\treturn this;\n\t}\n}\n\nclass EntityBatchArrayBuffer extends Entity {\n\tconstructor(buffer, offset, numberOfEntities, entityFieldsCount) {\n\t\tsuper();\n\t\tthis.buffer = buffer;\n\t\tthis.initialOffset = offset;\n\t\tthis.bufferEnd = offset + numberOfEntities * entityFieldsCount;\n\t\tthis.numberOfEntities = numberOfEntities;\n\t\tthis.entityFieldsCount = entityFieldsCount;\n\t}\n}\n\nconst CELL_WIDTH = 1;\nconst CELL_HEIGHT = 1;\n\n/**\n * Represents a single unit on an abstract 2D grid.\n *\n * The width and height of the cell are the equal.\n * The grid is uniform.\n * @extends Entity\n */\nclass Cell extends Entity {\n\t/**\n\t * Create a new cell.\n\t * @param {number} row - The horizontal location of the cell on a grid.\n\t * @param {number} col - The vertical location of the cell on a grid.\n\t */\n\tconstructor(row, col, state = CellStates.ACTIVE) {\n\t\tsuper();\n\t\tthis.className = 'Cell';\n\t\tthis.row = row;\n\t\tthis.col = col;\n\t\tthis.state = state;\n\t}\n\n\t/**\n\t * Intersection Test. Is the cell inside of a provided rectangle.\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} xx\n\t * @param {number} yy\n\t * @returns {boolean}\n\t */\n\tisInsideRect(x, y, xx, yy) {\n\t\treturn x <= this.row && this.row <= xx && y <= this.col && this.col <= yy;\n\t}\n\n\t/**\n\t * Create a deep copy of the cell.\n\t * @returns {Cell}\n\t */\n\tclone() {\n\t\treturn new Cell(this.row, this.col);\n\t}\n\n\trightBoundary() {\n\t\treturn this.row + CELL_WIDTH;\n\t}\n\n\tlowerBoundary() {\n\t\treturn this.col + CELL_HEIGHT;\n\t}\n\n\tstatic buildInstance(params) {\n\t\treturn new Cell().copyParams(params);\n\t}\n\n\tstatic mergeObjsWithCells(cells, objs) {\n\t\tobjs.forEach((obj) => {\n\t\t\t//Don't include any boxes.\n\t\t\tif (\n\t\t\t\tobj.className === 'Cell' &&\n\t\t\t\t!cells.some((c) => c.row == obj.row && c.col == obj.col)\n\t\t\t) {\n\t\t\t\tcells.push(this.buildInstance(obj));\n\t\t\t}\n\t\t});\n\t}\n}\n\nclass DeadCell extends Cell {\n\tconstructor(row, col) {\n\t\tsuper(row, col);\n\t}\n\n\tgetState() {\n\t\treturn CellStates.DEAD;\n\t}\n}\n\n/**\n * A grid.\n */\nclass GridEntity extends Entity {\n\t/**\n\t * Creates a new grid entity\n\t * @param {number} width - The total width of the grid.\n\t * @param {number} height - The total height of the grid.\n\t * @param {number} cWidth - The width of a grid cell.\n\t * @param {number} cHeight - The height of a grid cell.\n\t */\n\tconstructor(width = null, height = null, cWidth = null, cHeight = null) {\n\t\tsuper();\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.cell = { width: cWidth, height: cHeight };\n\t\tthis.className = 'GridEntity';\n\t}\n\n\tstatic buildInstance(params, traitBuilderMap = null) {\n\t\tlet entity = new GridEntity().copyParams(params);\n\t\ttraitBuilderMap && entity.initTraits(params, traitBuilderMap);\n\t\treturn entity;\n\t}\n}\n\n/**\n * Represents a box that can be processed via Traits.\n */\nclass Box extends Entity {\n\t/**\n\t * Creates a new Box.\n\t * @param {number} x - Left most X coordinate.\n\t * @param {number} y - Upper most Y coordinate.\n\t * @param {number} xx - Right most X coordinate.\n\t * @param {number} yy - Lower most Y coordinate.\n\t * @param {boolean} alive - If the cell is alive or not.\n\t */\n\tconstructor(x = null, y = null, xx = null, yy = null, alive = null) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.xx = xx;\n\t\tthis.yy = yy;\n\t\tthis.alive = alive;\n\t\tthis.className = 'Box';\n\t}\n\n\tstatic buildInstance(params, traitBuilderMap = null) {\n\t\tlet box = new Box().copyParams(params);\n\t\ttraitBuilderMap && box.initTraits(params, traitBuilderMap);\n\t\treturn box;\n\t}\n}\n\nmodule.exports = {\n\tBox,\n\tCell,\n\tDeadCell,\n\tEntity,\n\tEntityBatch,\n\tEntityBatchArrayBuffer,\n\tGridEntity,\n\tCELL_HEIGHT,\n\tCELL_WIDTH,\n};\n","const handler = {\n\tget: function (obj, prop) {\n\t\treturn prop in obj ? obj[prop] : 'Undefined Command';\n\t},\n};\n\nmodule.exports = new Proxy(\n\t{\n\t\tLifeCycle: new Proxy(\n\t\t\t{\n\t\t\t\tSTART: 'START',\n\t\t\t\tSTOP: 'STOP',\n\t\t\t\tPAUSE: 'PAUSE',\n\t\t\t\tPROCESS_CYCLE: 'PROCESS_CYCLE',\n\t\t\t},\n\t\t\thandler\n\t\t),\n\t\tDrawingSystemCommands: new Proxy(\n\t\t\t{\n\t\t\t\tSET_CELLS: 'SET_CELLS',\n\t\t\t\tSET_CELL_SIZE: 'SET_CELL_SIZE',\n\t\t\t\tSEND_CELLS: 'SEND_CELLS',\n\t\t\t\tRESET: 'RESET',\n\t\t\t\tTOGGLE_CELL: 'TOGGLE_CELL',\n\t\t\t\tDISPLAY_STORAGE: 'DISPLAY_STORAGE',\n\t\t\t\tDRAW_TEMPLATE: 'DRAW_TEMPLATE',\n\t\t\t\tDRAW_LINEAR_ELEMENTRY_CA: 'DRAW_LINEAR_ELEMENTRY_CA',\n\t\t\t},\n\t\t\thandler\n\t\t),\n\t\tLifeSystemCommands: new Proxy(\n\t\t\t{\n\t\t\t\tDISPLAY_STORAGE: 'DISPLAY_STORAGE',\n\t\t\t\tRESET: 'RESET',\n\t\t\t\tSEND_ALIVE_CELLS_COUNT: 'SEND_ALIVE_CELLS_COUNT',\n\t\t\t\tSEND_CELLS: 'SEND_CELLS',\n\t\t\t\tSEND_SIMULATION_ITERATIONS_COUNT: 'SEND_SIMULATION_ITERATIONS_COUNT',\n\t\t\t\tSET_CELL_SIZE: 'SET_CELL_SIZE',\n\t\t\t\tSET_CONFIG: 'SET_CONFIG',\n\t\t\t\tSET_SEEDER: 'SET_SEEDER',\n\t\t\t},\n\t\t\thandler\n\t\t),\n\t},\n\thandler\n);\n","const CellStates = require('./../entity-system/CellStates.js');\n\n/**\n * Enforces the simulation (game) rules.\n */\nclass CellEvaluator {\n\t/**\n\t * Creates a new evaluator.\n\t * @param {number[]} birthRules - The required alive neighbors for a cell to be born.\n\t * @param {number[]} survivalRules - The required alive neighbors for a cell to stay alive.\n\t */\n\tconstructor(birthRules, survivalRules) {\n\t\tthis.birthRules = birthRules;\n\t\tthis.survivalRules = survivalRules;\n\t}\n\n\tevaluate(neighborsCount, currentCellState) {\n\t\tlet nextCellState = CellStates.DEAD; //Be dead by default\n\t\tif (\n\t\t\tcurrentCellState == CellStates.DEAD &&\n\t\t\tthis.birthRules.includes(neighborsCount)\n\t\t) {\n\t\t\tnextCellState = CellStates.ACTIVE; //Be Born\n\t\t} else if (\n\t\t\tcurrentCellState == CellStates.ACTIVE &&\n\t\t\tthis.survivalRules.includes(neighborsCount)\n\t\t) {\n\t\t\tnextCellState = CellStates.ACTIVE; //Survive\n\t\t}\n\t\treturn nextCellState;\n\t}\n}\n\n/**\n * An evaluator for Life that is slightly optimized.\n */\nclass LifeEvaluator extends CellEvaluator {\n\tconstructor(birthRules, survivalRules) {\n\t\tsuper(birthRules, survivalRules);\n\t}\n\n\tevaluate(neighborsCount, currentCellState) {\n\t\tlet nextCellState = CellStates.DEAD; //Be dead by default\n\t\tif (currentCellState == CellStates.DEAD) {\n\t\t\tif (neighborsCount == 3) {\n\t\t\t\tnextCellState = CellStates.ACTIVE; //Born\n\t\t\t}\n\t\t} else if (currentCellState == CellStates.ACTIVE) {\n\t\t\tif (neighborsCount == 2 || neighborsCount == 3) {\n\t\t\t\tnextCellState = CellStates.ACTIVE; //Survives\n\t\t\t}\n\t\t}\n\t\treturn nextCellState;\n\t}\n}\n\nclass LifeLike extends CellEvaluator {\n\tconstructor(birthRules, survivalRules) {\n\t\tsuper(birthRules, survivalRules);\n\t}\n}\n\nclass GenerationalCellEvaluator extends CellEvaluator {\n\t/**\n\t * Creates a new evaluator.\n\t * @param {number[]} birthRules - The required alive neighbors for a cell to be born.\n\t * @param {number[]} survivalRules - The required alive neighbors for a cell to stay alive.\n\t */\n\tconstructor(birthRules, survivalRules, maxAge) {\n\t\tsuper(birthRules, survivalRules);\n\t\tthis.maxAge = maxAge;\n\t}\n\n\t/**\n\t * Evaluates a cell's next state based on the generations algorithm.\n\t * Generations Algorithm\n\t *  1. Dead cells can be born if the number of Moore active neighbors are included in the birth rules.\n\t *  2. Alive cells can stay \"active\" if the number of Moore neighbors are included in the survive rules.\n\t * \t\t Cells aren't aging while active.\n\t * \t\t Cells move into the retired stage once the above rule fails.\n\t *  3. Cells increment their age until they hit the max age then they die.\n\t * @param {number} neighborsCount - The number of a live cells the current cell has.\n\t * @param {CellState} currentCellState - the current state of cell.\n\t * @returns {CellState} The state the cell should be set to.\n\t */\n\tevaluate(neighborsCount, currentCellState) {\n\t\tlet nextCellState = CellStates.DEAD; //Be dead by default\n\t\tif (currentCellState === CellStates.DEAD) {\n\t\t\tif (this.birthRules.includes(neighborsCount)) {\n\t\t\t\tnextCellState = CellStates.ACTIVE; //Be Born\n\t\t\t}\n\t\t} else if (currentCellState === CellStates.ACTIVE) {\n\t\t\t//Determine if the cell should stay active.\n\t\t\tnextCellState = this.survivalRules.includes(neighborsCount)\n\t\t\t\t? CellStates.ACTIVE //Stay Active\n\t\t\t\t: CellStates.RETIRED; //Start aging...\n\t\t} else {\n\t\t\t//Aging\n\t\t\tnextCellState =\n\t\t\t\tcurrentCellState < this.maxAge\n\t\t\t\t\t? currentCellState + 1 // Age\n\t\t\t\t\t: (nextCellState = CellStates.DEAD); //Die\n\t\t}\n\n\t\treturn nextCellState;\n\t}\n}\n\nmodule.exports = { CellEvaluator, GenerationalCellEvaluator, LifeEvaluator };\n","/**\n * Conway's Game Initial State Seeder Module\n * @module seeders\n */\nconst CellStates = require('./../entity-system/CellStates.js');\nconst { Cell } = require('./../entity-system/Entities.js');\n\n/**\n * Randomly selects 0 or 1.\n * @private\n * @returns {number}\n */\nfunction randomAliveOrDead() {\n\treturn getRandomIntInclusive(CellStates.DEAD, CellStates.ACTIVE);\n}\n\n/**\n * Finds a random integer in the set defined by two bounds.\n * @private\n * @param {number} min\n * @param {number} max\n * @returns {number}\n */\nfunction getRandomIntInclusive(min, max) {\n\tmin = Math.ceil(min);\n\tmax = Math.floor(max);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive\n}\n\n/**\n * Abstract class. Defines a seeder.\n */\nclass Seeder {\n\t/**\n\t * Initialize a new seeder.\n\t */\n\tconstructor() {\n\t\tthis.cells = [];\n\t}\n\n\t/**\n\t * The algorithm to seed the simulation with.\n\t * @abstract\n\t * @param {number} width\n\t * @param {number} height\n\t */\n\tseed(width, height) {\n\t\tthrow new Error(\n\t\t\t'Seeder implementations must implement the seed(width, height) method.'\n\t\t);\n\t}\n\n\t/**\n\t * Initial cells to use by the seeder.\n\t * @param {Cell[]} cells\n\t */\n\tsetCells(cells) {\n\t\tthis.cells = cells;\n\t\treturn this;\n\t}\n}\n\n/**\n * Seeds a simulation with randomly selecting alive or dead for each cell.\n * @extends Seeder\n */\nclass RandomSeeder extends Seeder {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tseed(width, height) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\tlet birthChance = randomAliveOrDead();\n\t\t\t\tif (birthChance == 1) {\n\t\t\t\t\tthis.cells.push(new Cell(x, y, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.cells;\n\t}\n}\n\n/**\n * Seeds a simulation with a provided set of alive cells.\n * @extends Seeder\n */\nclass StaticCellsSeeder extends Seeder {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\tseed(width, height) {\n\t\treturn this.cells;\n\t}\n}\n\n/**\n * The set of supported seeder models.\n */\nSeederModels = {\n\tDRAWING: 'draw',\n\tRANDOM: 'random',\n};\n\n/**\n * Creates a new seeder based on a specified seeder model name.\n */\nclass SeederFactory {\n\t/**\n\t * Initializes a new seeder.\n\t * @param {string} modelName\n\t * @returns {Seeder}\n\t */\n\tstatic build(modelName) {\n\t\tlet seeder = null;\n\t\tswitch (modelName) {\n\t\t\tcase SeederModels.RANDOM:\n\t\t\t\tseeder = new RandomSeeder();\n\t\t\t\tbreak;\n\t\t\tcase SeederModels.DRAWING:\n\t\t\t\tseeder = new StaticCellsSeeder();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown seeder model name: ${modelName}`);\n\t\t}\n\t\treturn seeder;\n\t}\n}\n\nmodule.exports = { Seeder, SeederFactory, SeederModels };\n","/**\n * A web worker that is responsible for the Conway's Game of Life system.\n */\nconst { establishWorkerContext } = require('./WorkerUtils.js');\nconst LifeSystemWorkerController = require('./LifeSystemWorkerController');\n\nlet controller = new LifeSystemWorkerController(establishWorkerContext());\n\nfunction getController() {\n\treturn controller;\n}\n\nonmessage = function (event) {\n\tcontroller.process(event.data);\n};\n\nmodule.exports = {\n\tgetController,\n\tonmessage,\n};\n","function establishWorkerContext() {\n\treturn 'undefined' !== typeof WorkerGlobalScope ? self : this;\n}\n\nmodule.exports = { establishWorkerContext };\n","const WorkerCommands = require('./WorkerCommands.js');\nconst LifeSystemCmds = WorkerCommands.LifeSystemCommands;\nconst LifeSystem = require('./../core/LifeSystem.js');\n\nconst {\n\tAbstractWorkerController,\n\tPackingConstants,\n} = require('./AbstractWorkerController.js');\nconst { SeederFactory } = require('./../core/SeederFactory.js');\n\n/**\n * Controller for the Life System web worker.\n * @extends AbstractWorkerController\n */\nclass LifeSystemWorkerController extends AbstractWorkerController {\n\t/**\n\t * Creates a new instance of a LifeSystemWorkerController.\n\t * @param {WorkerGlobalScope} worker - The web worker that the controller performs orchestration for.\n\t */\n\tconstructor(worker) {\n\t\tsuper(worker);\n\t\tthis.lifeSystem = new LifeSystem();\n\t}\n\n\t/**\n\t * Route the inbound command to the appropriate processor.\n\t * @param {*} msg The message to be routed.\n\t * @override\n\t */\n\trouteCommand(msg) {\n\t\tswitch (msg.command) {\n\t\t\tcase LifeSystemCmds.RESET:\n\t\t\t\tthis.processCmd(\n\t\t\t\t\tmsg,\n\t\t\t\t\tmsg.command,\n\t\t\t\t\t(msg) => this.findPromisedProperty(msg, 'config'),\n\t\t\t\t\t(msg) => {\n\t\t\t\t\t\tthis.lifeSystem.reset(this.findPromisedProperty(msg, 'config'));\n\t\t\t\t\t\tmsg.promisedResponse &&\n\t\t\t\t\t\t\tthis.sendMessageToClient({\n\t\t\t\t\t\t\t\tid: msg.id,\n\t\t\t\t\t\t\t\tpromisedResponse: msg.promisedResponse,\n\t\t\t\t\t\t\t\tcommand: msg.command,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\t'The configuration was not provided.'\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase LifeSystemCmds.SEND_CELLS: //TODO: Make this use transferable. Where is this used?\n\t\t\t\tthis.processCmd(\n\t\t\t\t\tmsg,\n\t\t\t\t\tmsg.command,\n\t\t\t\t\t(msg) => this.findPromisedProperty(msg, 'promisedResponse'),\n\t\t\t\t\t(msg) => {\n\t\t\t\t\t\tlet cells = this.lifeSystem.getCells();\n\t\t\t\t\t\tlet response = {\n\t\t\t\t\t\t\tid: msg.id,\n\t\t\t\t\t\t\tpromisedResponse: msg.promisedResponse,\n\t\t\t\t\t\t\tcommand: msg.command,\n\t\t\t\t\t\t\tnumberOfCells: cells.length,\n\t\t\t\t\t\t\tcells: this.packScene(cells),\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.sendMessageToClient(response, [response.cells.buffer]);\n\t\t\t\t\t},\n\t\t\t\t\t'Could not send the life system cells.'\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase LifeSystemCmds.SET_CELL_SIZE:\n\t\t\t\tthis.processCmd(\n\t\t\t\t\tmsg,\n\t\t\t\t\tmsg.command,\n\t\t\t\t\t(msg) => msg.cellSize,\n\t\t\t\t\t(msg) => this.lifeSystem.setCellSize(msg.cellSize),\n\t\t\t\t\t'The cell size was not provided.'\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase LifeSystemCmds.SET_SEEDER:\n\t\t\t\tthis.processCmd(\n\t\t\t\t\tmsg,\n\t\t\t\t\tmsg.command,\n\t\t\t\t\t(msg) =>\n\t\t\t\t\t\tthis.findPromisedProperty(msg, 'config') &&\n\t\t\t\t\t\tthis.findPromisedProperty(msg, 'seedSetting'),\n\t\t\t\t\t(msg) => this.initializeSeeder(msg),\n\t\t\t\t\t'Setting the seeder requires including the config and seedingSetting properties. The cells property is optional.'\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase LifeSystemCmds.SET_CONFIG:\n\t\t\t\tthis.processCmd(\n\t\t\t\t\tmsg,\n\t\t\t\t\tmsg.command,\n\t\t\t\t\t(msg) => this.findPromisedProperty(msg, 'config'),\n\t\t\t\t\t(msg) =>\n\t\t\t\t\t\tthis.lifeSystem.setConfig(this.findPromisedProperty(msg, 'config')),\n\t\t\t\t\t'The config field was not provided.'\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Unsupported command ${msg.command} was received in LifeSystem Worker.`\n\t\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Updates the drawing scene and sends it to the client.\n\t * @override\n\t * @param {*} msg - The message to process.\n\t */\n\tprocessScene(msg) {\n\t\tif (this.systemRunning() && this.lifeSystem.canUpdate()) {\n\t\t\tthis.lifeSystem.update();\n\t\t\tlet aliveCellsCount = this.lifeSystem.aliveCellsCount();\n\t\t\tlet isSimulationDone = aliveCellsCount == 0;\n\t\t\tisSimulationDone && this.stop();\n\t\t\t\n\t\t\tlet sceneStack = this.lifeSystem.getScene().getStack();\n\n\t\t\tlet response = {\n\t\t\t\tcommand: msg.command,\n\t\t\t\tstack: this.packScene(sceneStack),\n\t\t\t\taliveCellsCount: aliveCellsCount,\n\t\t\t\tnumberOfSimulationIterations: this.lifeSystem.numberOfSimulationIterations(),\n\t\t\t\tnumberOfCells: sceneStack.length,\n\t\t\t\tcellFieldsCount: PackingConstants.FIELDS_PER_CELL,\n\t\t\t\tsimulationStopped: isSimulationDone,\n\t\t\t};\n\t\t\tthis.sendMessageToClient(response, [response.stack.buffer]);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the seeder for the life system. Sends a message back to the\n\t * client if promised a response.\n\t * @param {*} msg - The message to process.\n\t */\n\tinitializeSeeder(msg) {\n\t\tlet seedSetting = this.findPromisedProperty(msg, 'seedSetting');\n\t\tlet cellsBuffer = this.findPromisedProperty(msg, 'cellsBuffer');\n\t\tlet numberOfCells = this.findPromisedProperty(msg, 'numberOfCells');\n\t\tlet cells = this.unpackCells(\n\t\t\tcellsBuffer,\n\t\t\t0,\n\t\t\tnumberOfCells,\n\t\t\tPackingConstants.FIELDS_PER_CELL\n\t\t);\n\t\tlet seeder = SeederFactory.build(seedSetting).setCells(cells);\n\n\t\tthis.lifeSystem\n\t\t\t.setConfig(this.findPromisedProperty(msg, 'config'))\n\t\t\t.setSeeder(seeder)\n\t\t\t.initializeSimulation();\n\n\t\tmsg.promisedResponse &&\n\t\t\tthis.sendMessageToClient({\n\t\t\t\tid: msg.id,\n\t\t\t\tpromisedResponse: msg.promisedResponse,\n\t\t\t\tcommand: msg.command,\n\t\t\t});\n\t}\n}\n\nmodule.exports = LifeSystemWorkerController;\n","const GameManager = require('./GameManager.js');\nconst SceneManager = require('./SceneManager.js');\nconst {\n\tCellEvaluator,\n\tGenerationalCellEvaluator,\n\tLifeEvaluator,\n} = require('./CellEvaluator.js');\n/**\n * The possible states the drawing system can be in.\n * @private\n */\nconst States = {\n\tIDLE: 'IDLE',\n\tUPDATING: 'UPDATING',\n};\n\n/**\n * A Quad tree based Conway's Game of Life simulation.\n */\nclass LifeSystem {\n\tconstructor() {\n\t\tthis.config = {};\n\t\tthis.tickCounter = 0;\n\t\tthis.scene = new SceneManager();\n\t\tthis.stateManager = new GameManager(this.config);\n\t\tthis.displayStorageStructure = false;\n\t\tthis.state = States.IDLE;\n\t\tthis.seeder = null;\n\t\tthis.simulationInitialized = false;\n\t\tthis.cellEvaluator = undefined; //Will be set when calling this.setConfig()\n\t}\n\n\t/**\n\t * Getter for the internal system state.\n\t * @returns {State} Returns the active state.\n\t */\n\tgetState() {\n\t\treturn this.state;\n\t}\n\n\t/**\n\t * Replaces the current configuration.\n\t * @param {*} config The configuration.\n\t */\n\tsetConfig(config) {\n\t\tthis.config = config;\n\t\tthis.getStateManager().setConfig(this.config);\n\t\tthis.cellEvaluator = this.createCellEvaluator(this.config.game.activeGame);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @returns {SceneManager} The current scene.\n\t */\n\tgetScene() {\n\t\treturn this.scene;\n\t}\n\n\t/**\n\t * @returns {GameManager} Returns the state manager for the drawing system.\n\t */\n\tgetStateManager() {\n\t\treturn this.stateManager;\n\t}\n\n\t/**\n\t * Calculates if the system can perform an update or not.\n\t * @returns {Boolean}\n\t */\n\tcanUpdate() {\n\t\treturn this.state === States.IDLE;\n\t}\n\n\t/**\n\t * Used to preload the drawing system with alive cells.\n\t * @param {Cell[]} cells - An array of alive cells.\n\t */\n\tsetCells(cells) {\n\t\tthis.getStateManager().setCells(cells);\n\t}\n\n\t/**\n\t * Provides a deep copy of the currently alive cells.\n\t * @returns {Cell[]}\n\t */\n\tgetCells() {\n\t\treturn this.getStateManager().getCells();\n\t}\n\n\t/**\n\t * Sets the cell size to use.\n\t * @param {number} size The cell size\n\t */\n\tsetCellSize(size) {\n\t\tif (!this.config) {\n\t\t\tthis.config = {};\n\t\t}\n\t\tthis.config.zoom = size;\n\t}\n\n\t/**\n\t * Sets whether to draw the quad tree.\n\t * @param {boolean} display The display value.\n\t */\n\tdisplayStorage(display) {\n\t\tthis.displayStorageStructure = display;\n\t}\n\n\tgetDisplayStorage() {\n\t\treturn this.displayStorageStructure;\n\t}\n\n\t/**\n\t * Getter for the number of currently alive cells.\n\t * @returns {number} The count of alive cells.\n\t */\n\taliveCellsCount() {\n\t\treturn this.getStateManager().aliveCellsCount();\n\t}\n\n\t/**\n\t * Sets the simulation seeder to be used.\n\t * @param {Seeder} seeder - An implementation of the Seeder abstract class.\n\t */\n\tsetSeeder(seeder) {\n\t\tthis.seeder = seeder;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Processes the scene for one tick of the simulation.\n\t * @throws {Error} Throws an error if called before the simulation has been intialized.\n\t * @returns {LifeSystem} Returns the LifeSystem instance.\n\t */\n\tupdate() {\n\t\tif (this.simulationInitialized) {\n\t\t\tthis.scene.clear();\n\t\t\tthis.getStateManager()\n\t\t\t\t.evaluateCells(this.scene, this.cellEvaluator)\n\t\t\t\t.activateNext();\n\t\t\tthis.tickCounter++;\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot update. The simulation has not been initialized yet.'\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcreateCellEvaluator(game) {\n\t\tlet evaluator;\n\t\tif (game.key == 'conways-game-of-life') {\n\t\t\tevaluator = new LifeEvaluator(game.born, game.survive);\n\t\t} else if (game.maxAge) {\n\t\t\t//Generational Games\n\t\t\tevaluator = new GenerationalCellEvaluator(\n\t\t\t\tgame.born,\n\t\t\t\tgame.survive,\n\t\t\t\tgame.maxAge\n\t\t\t);\n\t\t} else {\n\t\t\tevaluator = new CellEvaluator(game.born, game.survive);\n\t\t}\n\t\treturn evaluator;\n\t}\n\n\t/**\n\t * Seeds the world when the simulation starts.\n\t * @returns {LifeSystem} Returns the LifeSystem instance.\n\t */\n\tinitializeSimulation() {\n\t\tif (!this.simulationInitialized) {\n\t\t\tthis.getStateManager().seedWorld(this.seeder);\n\t\t\tthis.simulationInitialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clears the simulation.\n\t * @returns {LifeSystem} Returns the LifeSystem instance.\n\t */\n\treset(config) {\n\t\tthis.tickCounter = 0;\n\t\tthis.simulationInitialized = false;\n\t\tthis.setConfig(config);\n\t\tthis.scene.clear();\n\t\tthis.getStateManager().clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the number of simulation ticks the life system has been updated.\n\t * @returns {number} Simulation ticks.\n\t */\n\tnumberOfSimulationIterations() {\n\t\treturn this.tickCounter;\n\t}\n}\n\nmodule.exports = LifeSystem;\n","const { CellMortonStore } = require('./CellMortonStore.js');\nconst { CellEvaluator } = require('./CellEvaluator.js');\nconst { Cell } = require('../entity-system/Entities.js');\nconst CellStates = require('./../entity-system/CellStates.js');\nconst { SeederFactory, SeederModels } = require('./SeederFactory.js');\n\n/**\n * Create the default cell evaluator.\n * @private\n * @returns {CellEvaluator}\n */\nfunction defaultCellEvaluator() {\n\treturn new CellEvaluator();\n}\n\n/**\n * Create the default simulation seeder.\n * @private\n * @returns {Seeder}\n */\nfunction defaultSeeder() {\n\treturn SeederFactory.build(SeederModels.RANDOM);\n}\n\n/**\n * Orchestrates Conway's Game of Life.\n */\nclass GameManager {\n\t/**\n\t * Create a new GameManager instance.\n\t * @param {object} config - The simulation's configuration object.\n\t */\n\tconstructor(config) {\n\t\tthis.config = config;\n\t\tthis.currentStore = new CellMortonStore();\n\t\tthis.nextStore = new CellMortonStore();\n\t}\n\n\tsetConfig(config) {\n\t\tthis.config = config;\n\t}\n\n\t/**\n\t * The number of cells currently alive in the simulation.\n\t * @returns {number}\n\t */\n\taliveCellsCount() {\n\t\treturn this.currentStore.size();\n\t}\n\n\t/**\n\t * Creates a deep copy of the cells in the drawing.\n\t * @returns {Cell[]} The copy of the cells.\n\t */\n\tgetCells() {\n\t\treturn this.currentStore.cells();\n\t}\n\n\t/**\n\t * Populates the current tree.\n\t */\n\tseedWorld(seeder = defaultSeeder()) {\n\t\tlet aliveCells = seeder.seed(\n\t\t\tthis.config.landscape.width,\n\t\t\tthis.config.landscape.height\n\t\t);\n\t\tthis.currentStore.addList(aliveCells);\n\t}\n\n\tevaluateCells(scene, evaluator = defaultCellEvaluator()) {\n\t\t//1. Traverse every possible cell on the landscape, building up a list of new alive cells.\n\t\t// prettier-ignore\n\t\tlet aliveNeighborsCount, nextCellState, x, y, xx, yy, cellsInArea, currentCellState;\n\t\tlet nextAliveCells = [];\n\t\tlet cellBin = new CellBin();\n\n\t\tfor (let row = 0; row < this.config.landscape.width; row++) {\n\t\t\tfor (let col = 0; col < this.config.landscape.height; col++) {\n\t\t\t\tcellsInArea = this.currentStore.neighborhood(\n\t\t\t\t\t{ row: row, col: col },\n\t\t\t\t\tthis.config.landscape.width,\n\t\t\t\t\tthis.config.landscape.height\n\t\t\t\t);\n\n\t\t\t\t//Assume the cell is dead.\n\t\t\t\tcurrentCellState = CellStates.DEAD;\n\t\t\t\taliveNeighborsCount = 0;\n\n\t\t\t\t//Find the current cell's state and the count of active cells.\n\t\t\t\tfor (let i = 0; i < cellsInArea.length; i++) {\n\t\t\t\t\tif (cellsInArea[i].row == row && cellsInArea[i].col == col) {\n\t\t\t\t\t\tcurrentCellState = cellsInArea[i].state;\n\t\t\t\t\t\tcontinue; //Don't count the current cell in the neighborhood calculation.\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cellsInArea[i].state === CellStates.ACTIVE) {\n\t\t\t\t\t\taliveNeighborsCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnextCellState = evaluator.evaluate(\n\t\t\t\t\taliveNeighborsCount,\n\t\t\t\t\tcurrentCellState\n\t\t\t\t);\n\n\t\t\t\tif (nextCellState !== CellStates.DEAD) {\n\t\t\t\t\t// nextAliveCells.push(new Cell(row, col, nextCellState));\n\t\t\t\t\tcellBin.add(new Cell(row, col, nextCellState));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//Merge the bins into a single pre-sorted array of cells.\n\t\tnextAliveCells = cellBin.merge();\n\t\tcellBin.clear();\n\n\t\t//2. Create a new hash store from the list of active and aging cells.\n\t\tthis.nextStore.clear();\n\t\tthis.nextStore.addList(nextAliveCells);\n\n\t\t//3. Feed the cells to the scene manager.\n\t\tscene.push(nextAliveCells);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the current tree with the next state tree and re-initializes the next tree to be empty.\n\t */\n\tactivateNext() {\n\t\tthis.currentStore.clear();\n\t\tthis.currentStore = null;\n\t\tthis.currentStore = this.nextStore;\n\t\tthis.nextStore = new CellMortonStore();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Purges the game manager of all alive cells.\n\t */\n\tclear() {\n\t\tthis.currentStore.clear();\n\t\tthis.nextStore.clear();\n\t}\n}\n\n/**\n * Stores cells in arrays partitioned by their state.\n */\nclass CellBin {\n\tconstructor() {\n\t\tthis.bin = new Map();\n\t}\n\n\tadd(cell) {\n\t\tif (cell && cell.state) {\n\t\t\tthis.bin.has(cell.state)\n\t\t\t\t? this.bin.get(cell.state).push(cell)\n\t\t\t\t: this.bin.set(cell.state, [cell]);\n\t\t} else {\n\t\t\tthrow new Error('Cannot add an undeclared Cell.');\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Creates a new array by combining the bins in increasing key order.\n\t * @returns {Cell[]} An array of cells.\n\t */\n\tmerge() {\n\t\tlet cells = [];\n\t\tlet groupedCells;\n\t\tlet keys = Array.from(this.bin.keys()).sort();\n\t\t//keys.forEach((k) => cells.push(...this.bin.get(k)));\n\t\tfor (let keyIndex = 0; keyIndex < keys.length; keyIndex++) {\n\t\t\tgroupedCells = this.bin.get(keys[keyIndex]);\n\t\t\tfor (let cellIndex = 0; cellIndex < groupedCells.length; cellIndex++) {\n\t\t\t\tcells.push(groupedCells[cellIndex]);\n\t\t\t}\n\t\t}\n\t\treturn cells;\n\t}\n\n\tclear() {\n\t\tthis.bin.clear();\n\t}\n}\nmodule.exports = GameManager;\n","//Borrowed from: https://github.com/mikolalysenko/bit-twiddle/blob/master/twiddle.js\nfunction encode(x, y) {\n\tx &= 0xffff; //Constrain to 16 bits. 0xffff is 65535 which is the number range of 16 bits. 1111111111111111 in binary. Numbers larger than 65535 will roll over.\n\tx = (x | (x << 8)) & 0x00ff00ff; //Shift to the left by 8. Mask: 111111110000000011111111\n\tx = (x | (x << 4)) & 0x0f0f0f0f; //Mask: 1111000011110000111100001111\n\tx = (x | (x << 2)) & 0x33333333; //Mask: 110011001100110011001100110011\n\tx = (x | (x << 1)) & 0x55555555; //Mask: 1010101010101010101010101010101\n\n\ty &= 0xffff;\n\ty = (y | (y << 8)) & 0x00ff00ff;\n\ty = (y | (y << 4)) & 0x0f0f0f0f;\n\ty = (y | (y << 2)) & 0x33333333;\n\ty = (y | (y << 1)) & 0x55555555;\n\n\treturn x | (y << 1);\n}\n\nfunction decode(zcode) {\n\treturn [deinterleave(zcode, 0), deinterleave(zcode, 1)];\n}\n\n//Based on https://github.com/mikolalysenko/bit-twiddle/blob/master/twiddle.js\nfunction deinterleave(zcode, component) {\n\tzcode = (zcode >>> component) & 0x55555555; // 1010101010101010101010101010101\n\tzcode = (zcode | (zcode >>> 1)) & 0x33333333; // 110011001100110011001100110011\n\tzcode = (zcode | (zcode >>> 2)) & 0x0f0f0f0f; // 1111000011110000111100001111\n\tzcode = (zcode | (zcode >>> 4)) & 0x00ff00ff; // 111111110000000011111111\n\tzcode = (zcode | (zcode >>> 8)) & 0x000ffff; // 1111111111111111\n\treturn (zcode << 16) >> 16;\n}\n\nfunction clip(value, min, max) {\n\treturn Math.min(max, Math.max(min, value));\n}\n\nclass CellMortonStore {\n\tconstructor(width, height) {\n\t\tthis.map = new Map();\n\t}\n\n\tsize() {\n\t\treturn this.map.size;\n\t}\n\n\taddList(cells) {\n\t\tfor (var i = 0; i < cells.length; i++) {\n\t\t\tthis.map.set(encode(cells[i].row, cells[i].col), cells[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\tadd(cell) {\n\t\tthis.map.set(encode(cell.row, cell.col), cell);\n\t\treturn this;\n\t}\n\n\tsearch(x, y) {\n\t\treturn this.get(encode(x, y));\n\t}\n\n\thas(zcode) {\n\t\treturn this.map.has(zcode);\n\t}\n\n\tget(zcode) {\n\t\treturn this.map.get(zcode);\n\t}\n\n\tdelete(x, y) {\n\t\treturn this.map.delete(encode(x, y));\n\t}\n\n\tclear() {\n\t\tthis.map.clear();\n\t\treturn this;\n\t}\n\n\tcells() {\n\t\treturn [...this.map.values()];\n\t}\n\n\t/**\n\t * Find all of the cells in a given cell's Moore neighborhood.\n\t *\n\t * {@link https://www.conwaylife.com/wiki/Cellular_automaton#Common_dimensions_and_neighborhoods | Moore Neighborhood}\n\t *\n\t * @param {*} cell\n\t */\n\tneighborhood(cell, width, height) {\n\t\tlet found = [];\n\t\tlet current;\n\n\t\t//constrain the neigborhood to the boundaries of the grid\n\t\tlet left = clip(cell.row - 1, 0, width);\n\t\tlet right = clip(cell.row + 1, 0, width);\n\t\tlet bottom = clip(cell.col - 1, 0, height);\n\t\tlet top = clip(cell.col + 1, 0, height);\n\n\t\tfor (var row = left; row <= right; row++) {\n\t\t\tfor (var col = bottom; col <= top; col++) {\n\t\t\t\tcurrent = this.get(encode(row, col));\n\t\t\t\tcurrent && found.push(current);\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n}\n\nmodule.exports = { decode, encode, CellMortonStore, clip };\n","/**\n * Data structure for storing the entities ready to render.\n */\nclass SceneManager {\n\t/**\n\t * Create a new SceneManager\n\t */\n\tconstructor() {\n\t\tthis.stack = [];\n\t}\n\n\t/**\n\t * Add a a single entity or an array of entities to the scene to be rendered.\n\t * @param {Entity | Entity[]} entity\n\t * @return {SceneManager} Returns the instance of the SceneManager.\n\t */\n\tpush(entity) {\n\t\tif (Array.isArray(entity)) {\n\t\t\tthis.stack = this.stack.concat(entity);\n\t\t} else {\n\t\t\tthis.stack.push(entity);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pop the next entity off the scene's stack.\n\t * @returns {Entity} The next entity to render.\n\t */\n\tnextEntity() {\n\t\treturn this.stack.shift();\n\t}\n\n\t/**\n\t * Determine if the stack is empty or not.\n\t * @returns {boolean}\n\t */\n\tfullyRendered() {\n\t\treturn !(this.stack.length > 0);\n\t}\n\n\t/**\n\t * Removes all entities from the stack.\n\t */\n\tclear() {\n\t\tthis.stack = [];\n\t}\n\n\tgetStack() {\n\t\treturn this.stack;\n\t}\n\n\tserializeStack() {\n\t\treturn JSON.stringify(this.stack);\n\t}\n}\n\nmodule.exports = SceneManager;\n","const WorkerCommands = require('./WorkerCommands.js');\nconst LifeCycle = WorkerCommands.LifeCycle;\nconst { Cell } = require('./../entity-system/Entities.js');\n\n/**\n * The possible states a web worker can be in.\n */\nconst WorkerState = {\n\tSTOPPED: 1,\n\tPAUSED: 2, //Reserved. Not currently used.\n\tRUNNING: 3,\n};\n\nconst PackingConstants = {\n\tBYTES_PER_NUMBER: 2,\n\tFIELDS_PER_CELL: 3,\n\tFIELDS_PER_BOX: 4,\n};\n\n/**\n * Base class that defines the common capabilities of the Web Worker controllers.\n */\nclass AbstractWorkerController {\n\tconstructor(worker) {\n\t\tthis.worker = worker;\n\t\tthis.workerState = WorkerState.STOPPED;\n\t}\n\n\t/**\n\t * The core logic of the controller. Responsible for routing incomming messages to\n\t * the appropriate command.\n\t * @param {*} msg - The message to process.\n\t */\n\tprocess(msg) {\n\t\tif (!msg.command) {\n\t\t\tthrow new Error(\n\t\t\t\t`${this.constructor.name}: Command not provided in message.`\n\t\t\t);\n\t\t}\n\t\tswitch (msg.command) {\n\t\t\tcase LifeCycle.START:\n\t\t\t\tthis.workerState = WorkerState.RUNNING;\n\t\t\t\tbreak;\n\t\t\tcase LifeCycle.STOP:\n\t\t\t\tthis.stop();\n\t\t\t\tbreak;\n\t\t\tcase LifeCycle.PAUSE:\n\t\t\t\tbreak;\n\t\t\tcase LifeCycle.PROCESS_CYCLE:\n\t\t\t\tthis.workerState === WorkerState.RUNNING && this.processScene(msg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.routeCommand(msg);\n\t\t}\n\t}\n\n\tstop() {\n\t\tthis.workerState = WorkerState.STOPPED;\n\t}\n\n\t/**\n\t * Route the inbound command to the appropriate processor.\n\t * @param {*} msg The message to be routed.\n\t */\n\trouteCommand(msg) {\n\t\tthrow new Error(\n\t\t\t'Child classes of AbstractWorkerController must implement the method routeCommand(msg).'\n\t\t);\n\t}\n\n\t/**\n\t * Processes an inbound message.\n\t * @param {*} msg - The message that was passed to the web worker.\n\t * @param {String} commandName - The enumerated command to process.\n\t * @param {Function} commandCriteria - Conditional that determines whether to run the command processor or not.\n\t * @param {Function} cmdProcessor - The command function to run when the criteria is met.\n\t * @param {String} errMsg - The error message to throw when the conditional isn't met.\n\t */\n\tprocessCmd(msg, commandName, commandCriteria, cmdProcessor, errMsg) {\n\t\tif (commandCriteria(msg)) {\n\t\t\tcmdProcessor(msg);\n\t\t} else {\n\t\t\tthrow new Error(`Cannot process the command ${commandName}: ${errMsg}`);\n\t\t}\n\t}\n\n\t/**\n\t * Finds a property regardless if it is a promised payload or not.\n\t * @param {*} msg - The message to inspect.\n\t * @param {*} name - The name of the property to find.\n\t * @returns The found property. Returns undefined if the property is not present.\n\t */\n\tfindPromisedProperty(msg, name) {\n\t\treturn msg.params ? msg.params[name] : msg[name];\n\t}\n\n\t/**\n\t * Processes the scene for a single tick.\n\t * @param {*} msg The message to process.\n\t */\n\tprocessScene(msg) {\n\t\tthrow new Error(\n\t\t\t'Child classes of AbstractWorkerController must implement the method processScene().'\n\t\t);\n\t}\n\n\t/**\n\t * @returns {Boolean} Determines if the service is running or not.\n\t */\n\tsystemRunning() {\n\t\treturn this.workerState === WorkerState.RUNNING;\n\t}\n\n\t/**\n\t * Sends a message to the web worker's client (main thread).\n\t * @param {*} msg The message to send.\n\t */\n\tsendMessageToClient(msg, transferList) {\n\t\tthis.worker.postMessage(msg, transferList);\n\t}\n\n\t//TODO: Put the buffer packing methods into their own class. This should be delegated.\n\t/*\n\tPacks the active scene as a Uint16Array. \n\t- Number range is [0,65535]\n\t- Each number is 2 bytes.\n\n\thttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n\t*/\n\tpackScene(sceneStack) {\n\t\t// prettier-ignore\n\t\tlet bufferLength = PackingConstants.BYTES_PER_NUMBER * PackingConstants.FIELDS_PER_CELL * sceneStack.length;\n\t\tlet buffer = new ArrayBuffer(bufferLength);\n\t\tlet dataView = new Uint16Array(buffer);\n\t\tlet offset;\n\n\t\t//First pack all the cells.\n\t\tfor (var current = 0; current < sceneStack.length; current++) {\n\t\t\toffset = PackingConstants.FIELDS_PER_CELL * current;\n\t\t\tdataView[offset] = sceneStack[current].row;\n\t\t\tdataView[offset + 1] = sceneStack[current].col;\n\t\t\tdataView[offset + 2] = sceneStack[current].state;\n\t\t}\n\t\t\n\t\treturn dataView;\n\t}\n\n\t/**\n\t\tConvert a typed array of cells into an array of Cells.\n\t\t@param {Uint16Array} buffer - The typed array containing cells.\n\t\t@param {number} offset - The index on the typed array to start the conversion.\n\t\t@param {number} numberOfCells - How many cells the typed array contains.\n\t\t@param {number} cellsFieldsCount - How many fields each cell contains.\n\t\t@returns {Cell[]}\n\t*/\n\tunpackCells(buffer, offset, numberOfCells, cellsFieldsCount) {\n\t\tlet cells = [];\n\t\tlet bufferEnd = offset + numberOfCells * cellsFieldsCount;\n\t\tif (buffer && ArrayBuffer.isView(buffer)) {\n\t\t\tfor (\n\t\t\t\tvar current = offset;\n\t\t\t\tcurrent < bufferEnd;\n\t\t\t\tcurrent += cellsFieldsCount\n\t\t\t) {\n\t\t\t\tcells.push(\n\t\t\t\t\tnew Cell(buffer[current], buffer[current + 1], buffer[current + 2])\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn cells;\n\t}\n}\n\nmodule.exports = { AbstractWorkerController, PackingConstants, WorkerState };\n"],"sourceRoot":""}